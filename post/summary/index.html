<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Course Summary - COMP3222 Musings</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="z5206677"><meta name=description content="Boolean Algebra Truth Table A truth table describes the boolean algebraic value of (an) output(s) given differing input values"><meta name=keywords content="featherbear,COMP3222,UNSW"><meta name=generator content="Hugo 0.68.3 with theme even"><link rel=canonical href=../../post/summary/><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../manifest.json><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><link href=../../sass/main.min.651e6917abb0239242daa570c2bec9867267bbcd83646da5a850afe573347b44.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=../../css/typedjs.shortcode.css><link rel=stylesheet href=../../css/fixDetails.css><link rel=stylesheet href=../../css/fancyBox.css><meta property="og:title" content="Course Summary"><meta property="og:description" content="Boolean Algebra Truth Table A truth table describes the boolean algebraic value of (an) output(s) given differing input values"><meta property="og:type" content="article"><meta property="og:url" content="/post/summary/"><meta property="article:published_time" content="2020-11-27T23:09:27+11:00"><meta property="article:modified_time" content="2021-10-19T15:48:52+11:00"><meta itemprop=name content="Course Summary"><meta itemprop=description content="Boolean Algebra Truth Table A truth table describes the boolean algebraic value of (an) output(s) given differing input values"><meta itemprop=datePublished content="2020-11-27T23:09:27+11:00"><meta itemprop=dateModified content="2021-10-19T15:48:52+11:00"><meta itemprop=wordCount content="1321"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Course Summary"><meta name=twitter:description content="Boolean Algebra Truth Table A truth table describes the boolean algebraic value of (an) output(s) given differing input values"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=../../ class=logo>COMP3222 Musings</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=../../><li class=mobile-menu-item>Home</li></a><a href=https://github.com/featherbear/UNSW-COMP3222><li class=mobile-menu-item>GitHub</li></a><a href=../../categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=../../ class=logo>COMP3222 Musings</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=../../>Home</a></li><li class=menu-item><a class=menu-item-link href=https://github.com/featherbear/UNSW-COMP3222>GitHub</a></li><li class=menu-item><a class=menu-item-link href=../../categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Course Summary</h1><div class=post-meta><span class=post-time>2020-11-27</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#boolean-algebra>Boolean Algebra</a><ul><li><a href=#truth-table>Truth Table</a></li><li><a href=#duals>Duals</a></li><li><a href=#karnaugh-map>Karnaugh Map</a></li><li><a href=#rules>Rules</a></li></ul></li><li><a href=#circuits>Circuits</a><ul><li><a href=#costs>Costs</a></li><li><a href=#circuit-synthesis>Circuit Synthesis</a></li><li><a href=#physical-circuit-design>Physical Circuit Design</a></li></ul></li><li><a href=#circuit-devices>Circuit Devices</a><ul><li><a href=#multiplexer--mux>Multiplexer / Mux</a></li><li><a href=#gates>Gates</a></li><li><a href=#gate-conversion>Gate Conversion</a></li><li><a href=#adder-circuits>Adder Circuits</a></li><li><a href=#subtraction-circuits>Subtraction Circuits</a></li><li><a href=#multiplication-circuit>Multiplication Circuit</a></li><li><a href=#division>Division</a></li><li><a href=#encoders-and-decoders>Encoders and Decoders</a></li><li><a href=#registers>Registers</a></li><li><a href=#three-state--tri-state-buffers>Three State / Tri-State Buffers</a></li><li><a href=#counters>Counters</a></li></ul></li><li><a href=#clocks>Clocks</a><ul><li><a href=#circuit-delays>Circuit Delays</a></li><li><a href=#clock-skew>Clock Skew</a></li></ul></li><li><a href=#synchronous-circuits>Synchronous Circuits</a></li></ul></nav></div></div><div class=post-content><h1 id=boolean-algebra>Boolean Algebra</h1><h2 id=truth-table>Truth Table</h2><p>A truth table describes the boolean algebraic value of (an) output(s) given differing input values</p><h2 id=duals>Duals</h2><p>The <code>dual</code> of an algebraic boolean expression is a sort of complement form that infers the same meaning.</p><ul><li>OR &lt;-> AND (Switch AND and OR statements)</li><li>0 &lt;-> 1 (Switch 0 and 1 values)</li></ul><h2 id=karnaugh-map>Karnaugh Map</h2><p>A Karnaugh Map helps to simplify functions by reducing the number of required terms to achieve the same function.</p><ul><li>Set the columns as the most significant variables</li><li>Set the rows as the least significant variables</li></ul><p>Note: The ratio of columns to rows is unimportant (but it's good to attempt to keep them relatively 1:1)</p><ul><li>Karnaugh Maps are grey-encoded - When laying out columns and rows, the next column/row can <strong>only</strong> differ by one bit.<ul><li><strong>Do: 00, 01, 11, 10</strong></li><li><strong>Don't: 00, 01, 10, 11</strong></li></ul></li></ul><p>To use a Karnaugh Map, find simplified conditions for which a set of values are all 1 (or 0 for maxterms).</p><ul><li>Note: A Karnaugh Map forms a torus - the end of a column/row is connected to its start</li><li>Note: It may be possible to combine the Karnaugh Map with other similar circuits, which can reduce the number of required components</li></ul><h2 id=rules>Rules</h2><p><img src=../intro-to-synthesis/2020-09-16-14-59-05.png alt></p><h1 id=circuits>Circuits</h1><h2 id=costs>Costs</h2><p>The "cost" of a circuit can be explored as the sum of the number of gates and the number of gate inputs.</p><blockquote><p><code>cost = #gates + #gate_inputs</code></p></blockquote><p>This is a good measure of cost as less gates will require fewer transistors.</p><p><strong>When dealing with inverted input values, those gates are not counted</strong></p><h2 id=circuit-synthesis>Circuit Synthesis</h2><p>Given a truth table, an expression can be formed from the sum of <code>f=1</code> entries.</p><ul><li><code>minterm</code> - a product term (AND) where each term appears only once (regardless of complement)</li><li><code>maxterm</code> - a sum term (OR) where each term appears only once; a complement of the minterm</li></ul><hr><ul><li>Sum of Products - Sum of <code>minterms</code><ul><li>Canonical SOP - If each product term is a minterm</li></ul></li><li>Product of Sums - Product of <code>maxterms</code><ul><li>Canonical POS - If each sum term is a maxterm</li></ul></li></ul><h2 id=physical-circuit-design>Physical Circuit Design</h2><p>There is a physical limit to the number of inputs that they can have - for example: propagation time. As such, there are a number of ways to 'refactor' the design.</p><p>i.e. Decrease the number of inputs for each gate, but add a second gate</p><h1 id=circuit-devices>Circuit Devices</h1><p>The speed of a circuit is bound by the longest delay along the paths in that circuit.<br>The longest path is called the <code>critical path</code>, and its delay is known as the <code>critical path delay</code></p><h2 id=multiplexer--mux>Multiplexer / Mux</h2><p>Switches an output given a set of inputs.</p><blockquote><p>$f = \overline{s}\cdot{x_0} + {s}\cdot{x_1}</p></blockquote><h3 id=shannons-expansion-theorem>Shannon's Expansion Theorem</h3><blockquote><p>Mux implementations of logic functions require that a given function to be decomposed with respect to the variables that are used as the select inputs</p></blockquote><p>Variable split -> $f(w_1, w_2, ...) -> w_1f_{w_1}(1, w_2, ...) + \overline{w_1}f_\overline{w_1}(0, w_2, ...)$</p><p>We can also split multiple variables - breaking them into permutations of terms</p><h2 id=gates>Gates</h2><p>NAND and NOR gates are used in favour of AND and OR gates due to the nature of how they are built. NAND and NOR gates pull the input voltage to zero if certain cases (given by their functionality) are met. As a result of this implementation, AND and OR gates get their operation through gating the NAND/NOR gate with a NOT gate - which requires an additional 2 transistors.</p><h3 id=not-gate>NOT Gate</h3><ul><li>$\overbar{x}$</li><li>Requires 2 transistors</li></ul><h3 id=nor-gate>NOR Gate</h3><ul><li>Requires 4 transistors</li></ul><h3 id=nand-gate>NAND Gate</h3><ul><li>Requires 4 transistors</li></ul><h3 id=and-gate>AND Gate</h3><ul><li>Requires 6 transistors (AND + NOT)</li></ul><h2 id=gate-conversion>Gate Conversion</h2><h3 id=nand-conversion-in-a-sop-network>NAND Conversion (In a SOP network)</h3><ul><li>Add bubbles (<code>NOT</code>) to the output of every <code>AND</code> gate</li><li>Add bubbles (<code>NOT</code>) to the input of every <code>OR</code> gate</li><li>Replace <code>OR</code> gates with bubbled inputs to <code>NAND</code> gates</li></ul><h3 id=nor-conversion-in-a-pos-network>NOR Conversion (In a POS network)</h3><ul><li>Add bubbles (<code>NOT</code>) to the output of every <code>OR</code> gate</li><li>Add bubbles (<code>NOT</code>) to the input of every <code>AND</code> gate</li><li>Equalise bubbles (Cancel out double-<code>NOT</code>)</li><li>Replace <code>AND</code> gates with bubbled inputs to <code>NOR</code> gates</li></ul><h2 id=adder-circuits>Adder Circuits</h2><p>Adds bits together giving an output, and a carry bit.<br>Several adder components can be stacked together to create an <code>n-bit adder</code>.</p><h3 id=carry-lookahead>Carry Lookahead</h3><ul><li>A carry needs to be generated if <code>g = ab = 1</code></li><li>Otherwise, a carry needs to be propagated if <code>p = (a + b)cin</code></li></ul><p>An additional carry-lookhead logic block takes in these values of <code>g</code> and <code>p</code> for each bit-block; allowing future adders to take the <code>g</code> and <code>p</code> values of other blocks.</p><p>$c_i = g_n OR p_n$</p><ul><li>Carry bits produced after 3 gate delays</li><li>Sum bits produced after 4 gate delays</li><li>Each stage requires another AND gate with another state</li></ul><blockquote><p>Calculation: Minimum 4</p></blockquote><h2 id=subtraction-circuits>Subtraction Circuits</h2><p>Add the two's complement of a number X to perform a "subtraction of X" operation</p><h2 id=multiplication-circuit>Multiplication Circuit</h2><p>Add <code>n</code> time</p><h2 id=division>Division</h2><p>Move scope of dividend until divisor is subtractable</p><h2 id=encoders-and-decoders>Encoders and Decoders</h2><blockquote><p>Turning data from one form to another</p></blockquote><p>An $n$-bit signal could be turned into $2^n$ outputs, allowing a 'one-hot encoded' value to be formed (only one output is active at any given time)</p><h3 id=latches>Latches</h3><p>Respond while clock is high</p><ul><li>RS-Latch - Latch responds when clock is high<ul><li>Undefined behaviour when <code>S</code> and <code>R</code> are both asserted</li></ul></li><li>D-Latch - Latch responds when clock is high</li></ul><h3 id=flip-flop-circuits>Flip-Flop Circuits</h3><p>Respond only during transitions of the clock edge</p><ul><li>D-Flip-Flop - Set to D on clock transition</li><li>T-Flip-Flop - Toggle result when T is high</li><li><a href=../latches-and-flip-flops#jk-type-flip-flop>JK-Flip-Flop</a> - (Most versatile one) - Toggle, set, or hold</li></ul><h2 id=registers>Registers</h2><p>A register is a collection of flip-flop circuits that are grouped together</p><h3 id=shift-registers>Shift Registers</h3><p>Shift registers shift the incoming data either left or right</p><h3 id=parallel-access>Parallel Access</h3><p>Allows a shift register to be loaded in serially (by shifting), or all at once.<br>This is done by muxing the D-flip-flop input.</p><h2 id=three-state--tri-state-buffers>Three State / Tri-State Buffers</h2><p>Output is of a high impedance if $c = 0$, else output is the value of the input $i$.</p><h2 id=counters>Counters</h2><p>Store values, increment and/or decrement.</p><p>Increasing logic is performed by an AND gate (only increment if both previous register and register before that (...) are asserted)</p><p>Implementation: Use the same clock signals!</p><h1 id=clocks>Clocks</h1><p>Clocks are used to synchronise operations</p><h2 id=circuit-delays>Circuit Delays</h2><p>Devices take time for their outputs to be asserted correctly (floating values, physical connections, gate delays).</p><ul><li>Propagation Delay - $t_{cQ}$ - Time taken for the output to reflect an input change<ul><li>Beginning of input transition (ie clock) to output change</li></ul></li><li>Setup Time - $t_{su}$ - Time needed for the input to be stable prior to the triggering clock edge</li><li>Hold Time - $t_{h}$ - Time needed for the input to be stable after to the triggering clock edge</li></ul><p>$$ T_{min} = \frac{1}{F_{max}} $$</p><p>$$ T_{min}$ = max(t_{cQ}) + t_{NOT} + t_{su} $$
$$ F_{max} = \frac{1}{T_{min}} $$</p><p>Therefore, max clock speed is $ F_{max} $
Any faster, $t_{su}$ will not be satisfied</p><blockquote><p>To determine the shortest delay from any positive clock edge to flip-flop input.</p></blockquote><p>$$ min(t_{cQ}) + t_{NOT} > t_h $$</p><h2 id=clock-skew>Clock Skew</h2><p>Due to wire delays, the same clock edge may arrive at different times.<br>FPGA boards have special clock distribution networks that minimise the time difference of received clock edges.</p><ul><li>Positive Clock Skew can be beneficial - signals arrive earlier than expected; can calculate earlier</li><li>Negative Clock Sew is often harmful - signals arrive later, increase delay, reduce max frequency</li></ul><h1 id=synchronous-circuits>Synchronous Circuits</h1><ul><li>Sequential Circuit - output depends on past inputs and states, and present inputs</li></ul><p>Sequential circuits that use a clock signal are known as synchronous sequential circuits (FSM)</p><ul><li>Moore circuit - Output state depends <strong>solely</strong> on the current state ("step by step")</li><li>Mealy circuit - Output state depends on the current state and the current inputs</li></ul><hr><ul><li>State Diagram - Represents the transitions between states</li><li>State Table - Represents the outputs of a state, and the consequences of different inputs</li></ul><p>Note on Async Inputs: The output should be asserted until after the input has been asserted for 1 clock period.</p></div><footer class=post-footer><nav class=post-nav><a class=next href=../../post/implementation-technology/><span class="next-text nav-default">Implementation Technology</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-left"></i></a></nav></footer></article><script>(function(f,a,t,h,o,m){a[h]=a[h]||function(){(a[h].q=a[h].q||[]).push(arguments)};o=f.createElement('script'),m=f.getElementsByTagName('script')[0];o.async=1;o.src=t;o.id='fathom-script';m.parentNode.insertBefore(o,m)})(document,window,'//ss.featherbear.cc/tracker.js','fathom');fathom('set','siteId','NEQTU');fathom('trackPageview');</script></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:z5206677@student.unsw.edu.au class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/andrewjinmengwong/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/featherbear class="iconfont icon-github" title=github></a><a href=https://www.instagram.com/_andrewjwong/ class="iconfont icon-instagram" title=instagram></a><a href=../../index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2021
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Andrew Wong (z5206677)</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=../../js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js></script><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$'],['\\(','\\)']]},showProcessingMessages:false,messageStyle:'none'};</script><script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin=anonymous></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-107434487-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=../../js/typed.js@2.0.9></script><script src=../../js/typedjs.shortcode.js></script></body></html>